import logging
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey
import log_messages
from commons import Commons
import random
from random_tasks import random_tasks
import traceback

o_client = import_da('client')
o_replica = import_da('replica')


# noinspection PyMethodParameters
class Olympus(process):
    def setup(process_id):
        self._id = "o1"
        self._process_id = process_id
        self._config = {}
        self._config['clients'] = {}
        self._config['replicas'] = {}

        self._current_config = 0
        self.initialize()

    def parse_config():
        with open('config.txt', 'r') as f:
            for line in f:
                if line[0] != '#':
                    (key, sep, val) = line.partition('=')
                    # if the line does not contain '=', it is invalid and hence ignored
                    if len(sep) != 0:
                        val = val.strip()
                        self.save_config_line(key.strip(), int(val) if str.isdecimal(val) else val)
        output(log_messages.PARSED_CONFIG, self._config)

    def save_config_line(key, val):
        if key == 'hosts':
            hosts = {}
            id = 0
            for host in val.split("; "):
                hosts[id] = host
                id += 1
            self._config[key] = hosts
        elif key == 'client_hosts':
            client_hosts = {}
            id_num = 0
            hosts = self._config['hosts']
            for client_host_id in val.split(";"):
                client_host_id = client_host_id.strip()
                if client_host_id == '':
                    break
                client_hosts['c' + str(id_num)] = hosts[int(client_host_id)]
                id_num += 1
            self._config[key] = client_hosts
        elif key == 'replica_hosts':
            replica_hosts = {}
            id_num = 0
            hosts = self._config['hosts']
            for replica_host in val.split("; "):
                replica_hosts['r' + str(id_num)] = replica_host
                id_num += 1
            self._config[key] = replica_hosts
        elif "workload[" in key:
            workloads = self._config['workloads'] if 'workloads' in self._config else {}
            client_id = "c" + key[-2:-1]
            if (val.startswith('pseudorandom')):
                seed_start_index = val.index('(') + 1
                seed_end_index = val.index(')')
                seed_n_pair = val[seed_start_index:seed_end_index]
                seed_n_pair = seed_n_pair.split(',')
                seed, n = int(seed_n_pair[0].strip()), int(seed_n_pair[1].strip())

                random.seed(seed)
                workloads[client_id] = [random.choice(random_tasks) for i in range(n)]
            else:
                workloads[client_id] = val.split("; ")

            self._config['workloads'] = workloads
        elif "failures[" in key:
            failures = self._config['failures'] if 'failures' in self._config else {}
            config_replica = key[9:-1]
            config_num = int(config_replica.strip().split(",")[0])
            replica_id = 'r' + config_replica.strip().split(",")[1]
            config_failure = failures[config_num] if config_num in failures else {}
            config_failure[replica_id] = {}
            if len(val.split("; ")) > 0:
                config_failure[replica_id] = _parse_failure_triggers(val.split("; "))
            failures[config_num] = config_failure
            self._config['failures'] = failures
        else:
            self._config[key] = val

    def _parse_failure_triggers(failure_triggers):
        parsed_failure_triggers = {}
        for failure_trigger in failure_triggers:
            trigger = failure_trigger.split(",")[0].strip()
            trigger_type = trigger.split("(")[0].strip()
            client_id = 'c' + trigger.split("(")[1].split(",")[0].strip()
            trigger_num = failure_trigger.split(",")[1].strip()[:-1]
            failure = failure_trigger.split("),")[1].strip()
            failure_type = failure.split("(")[0].strip()
            failure_arg = failure.split("(")[1].strip()[:-1]
            parsed_failure = parsed_failure_triggers[client_id] if client_id in parsed_failure_triggers else {}
            parsed_failure_trigger_type = parsed_failure[
                trigger_type] if trigger_type in parsed_failure_triggers else {}
            parsed_failure_trigger_type[trigger_num] = [failure_type, failure_arg]
            parsed_failure[trigger_type] = parsed_failure_trigger_type
            parsed_failure_triggers[client_id] = parsed_failure
        return parsed_failure_triggers

    def generate_keys():
        self._config['keys'] = {}
        self._config['keys']['private_keys'] = {}
        self._config['keys']['public_keys'] = {}
        # Generate keys for Olympus
        self.set_keys(self._id, SigningKey.generate())
        # Generate keys for Clients
        for client_id in self._config['client_hosts'].keys():
            self.set_keys(client_id, SigningKey.generate())
        # Generate keys for Replicas
        for replica_id in self._config['replica_hosts'].keys():
            self.set_keys(replica_id, SigningKey.generate())
        output(log_messages.GENERATED_KEYS, self._config['keys'])

    def set_keys(id, private_key):
        self._config['keys']['private_keys'][id] = private_key
        self._config['keys']['public_keys'][id] = private_key.verify_key.encode(encoder=HexEncoder)

    def init_clients():
        workloads = self._config['workloads']
        for client_id, host in self._config['client_hosts'].items():
            client_config = get_client_config(client_id)
            client = self._config['clients'][client_id]
            setup(client, args=(client_config,))
            start(client)

    def get_client_config(client_id):
        client_config = {
            'id': client_id,
            'workload': self._config['workloads'][client_id],
            'private_key': self._config['keys']['private_keys'][client_id],
            'public_keys': self._config['keys']['public_keys'],
            'client_timeout': self._config['client_timeout'] / 1000,
            'olympus': {'id': self._id, 'process_id': self._process_id},
            'replicas': self._config['replicas'],
            'head_id': self._config['head_id']
        }
        return client_config

    def init_replicas():
        prev_replica = None
        preceding_replica_ids = []
        self._config['replicas'] = {}
        self._config['replicas'] = {'r' + str(id_num): new(o_replica.Replica)
                                    for id_num in range(0, len(self._config['replica_hosts']))}
        for id_num in range(0, len(self._config['replica_hosts'])):
            replica_id = 'r' + str(id_num)
            replica = self._config['replicas'][replica_id]
            replica_config = {
                'id': replica_id,
                'clients': self._config['clients'],
                'private_key': self._config['keys']['private_keys'][replica_id],
                'public_keys': self._config['keys']['public_keys'],
                'timeout': self._config['nonhead_timeout'] / 1000,
                'prev_replica_ids': preceding_replica_ids,
                'type': 'replica',
                'current_config': self._current_config,
                'prev_replica': prev_replica,
                'replicas': self._config['replicas']
            }
            next_replica_id = 'r' + str(id_num + 1)
            replica_config['next_replica'] = self._config['replicas'][next_replica_id] \
                if next_replica_id in self._config['replicas'].keys() else None
            replica_config['failures'] = []
            if self._current_config in self._config['failures']:
                if replica_id in self._config['failures'][self._current_config]:
                    replica_config['failures'] = self._config['failures'][self._current_config][replica_id]

            if id_num == 0:
                replica_config['type'] = 'head'
                replica_config['timeout'] = self._config['head_timeout'] / 1000
                self._config['head_id'] = replica_id
            elif id_num == len(self._config['replica_hosts']) - 1:
                replica_config['type'] = 'tail'
                self._config['tail_id'] = replica_id

            prev_replica = replica
            preceding_replica_ids.append(replica_id)
            id_num += 1
            setup(replica, args=(replica_config,))
            start(replica)

    def initialize():
        self.parse_config()
        self.generate_keys()
        self.create_clients()
        self.init_replicas()
        self.init_clients()

    def run():
        await(False)

    # On receipt of a config_request from a client
    def receive(msg=('config_request', message, client_id), from_=self._config['clients'].values()):
        if not Commons.is_valid_signature(message['signed_content'], self._config['keys']['public_keys'][client_id]):
            output(log_messages.INVALID_SIGNATURE, client_id, level=logging.ERROR)
            return

        output(log_messages.CONFIG_REQUEST_RECEIVED, client_id)

        config_message = {
            'content': get_client_config(client_id)
        }
        config_message['signed_content'] = Commons.sign(config_message['content'],
                                                        self._config['keys']['private_keys'][self._id])
        # send(('config', config_message), to=self._config['clients'][client_id])
        output(log_messages.CONFIG_SENT, client_id)

    def create_clients():
        for client_id, host in self._config['client_hosts'].items():
            self._config['clients'][client_id] = new(o_client.Client)


def main():
    config(channel={'reliable', 'fifo'})
    olympus = new(Olympus)
    setup(olympus, args=(olympus,))
    start(olympus)
    await(False)