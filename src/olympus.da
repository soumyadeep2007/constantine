import logging
import sys
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey
import log_messages
from commons import Commons
import random
from random_tasks import random_tasks
import traceback

o_client = import_da('client')
o_replica = import_da('replica')


# noinspection PyMethodParameters
class Olympus(process):
    def setup(process_id, file_path):
        self._id = "o1"
        self._process_id = process_id
        self._config = {'clients': {}, 'replicas': {}, 'failures': {}}
        self._replicas = []
        self.file_path = file_path
        self._num_wedged_responses = 0

        self._current_config = 0
        try:
            self.initialize()
        except:
            traceback.print_exc()

    def parse_config():
        with open(self.file_path, 'r') as f:
            for line in f:
                if line[0] != '#':
                    (key, sep, val) = line.partition('=')
                    # if the line does not contain '=', it is invalid and hence ignored
                    if len(sep) != 0:
                        val = val.strip()
                        self.save_config_line(key.strip(), int(val) if str.isdecimal(val) else val)
        output(log_messages.PARSED_CONFIG, self._config)

    def save_config_line(key, val):
        if key == 'hosts':
            hosts = {}
            id = 0
            for host in val.split("; "):
                hosts[id] = host
                id += 1
            self._config[key] = hosts
        elif key == 'client_hosts':
            client_hosts = {}
            id_num = 0
            hosts = self._config['hosts']
            for client_host_id in val.split(";"):
                client_host_id = client_host_id.strip()
                if client_host_id == '':
                    break
                client_hosts['c' + str(id_num)] = hosts[int(client_host_id)]
                id_num += 1
            self._config[key] = client_hosts
        elif key == 'replica_hosts':
            replica_hosts = {}
            id_num = 0
            hosts = self._config['hosts']
            for replica_host in val.split("; "):
                replica_hosts['r' + str(id_num)] = replica_host
                id_num += 1
            self._config[key] = replica_hosts
        elif "workload[" in key:
            workloads = self._config['workloads'] if 'workloads' in self._config else {}
            client_id = "c" + key[-2:-1]
            if (val.startswith('pseudorandom')):
                seed_start_index = val.index('(') + 1
                seed_end_index = val.index(')')
                seed_n_pair = val[seed_start_index:seed_end_index]
                seed_n_pair = seed_n_pair.split(',')
                seed, n = int(seed_n_pair[0].strip()), int(seed_n_pair[1].strip())

                random.seed(seed)
                workloads[client_id] = [random.choice(random_tasks) for i in range(n)]
            else:
                workloads[client_id] = val.split("; ")

            self._config['workloads'] = workloads
        elif "failures[" in key:
            failures = self._config['failures'] if 'failures' in self._config else {}
            config_replica = key[9:-1]
            config_num = int(config_replica.strip().split(",")[0])
            replica_id = 'r' + config_replica.strip().split(",")[1]
            config_failure = failures[config_num] if config_num in failures else {}
            config_failure[replica_id] = {}
            if len(val.split("; ")) > 0:
                config_failure[replica_id] = _parse_failure_triggers(val.split("; "))
            failures[config_num] = config_failure
            self._config['failures'] = failures
        else:
            self._config[key] = val

    def _parse_failure_triggers(failure_triggers):
        parsed_failure_triggers = {}
        for failure_trigger in failure_triggers:
            trigger = failure_trigger.split(",")[0].strip()
            trigger_type = trigger.split("(")[0].strip()
            client_id = 'c' + trigger.split("(")[1].split(",")[0].strip()
            trigger_num = failure_trigger.split(",")[1].strip()[:-1]
            failure = failure_trigger.split("),")[1].strip()
            failure_type = failure.split("(")[0].strip()
            failure_arg = failure.split("(")[1].strip()[:-1]
            parsed_failure = parsed_failure_triggers[client_id] if client_id in parsed_failure_triggers else {}
            parsed_failure_trigger_type = parsed_failure[
                trigger_type] if trigger_type in parsed_failure_triggers else {}
            parsed_failure_trigger_type[trigger_num] = [failure_type, failure_arg]
            parsed_failure[trigger_type] = parsed_failure_trigger_type
            parsed_failure_triggers[client_id] = parsed_failure
        return parsed_failure_triggers

    def generate_keys():
        self._config['keys'] = {}
        self._config['keys']['private_keys'] = {}
        self._config['keys']['public_keys'] = {}
        # Generate keys for Olympus
        self.set_keys(self._id, SigningKey.generate())
        # Generate keys for Clients
        for client_id in self._config['client_hosts'].keys():
            self.set_keys(client_id, SigningKey.generate())
        # Generate keys for Replicas
        self.generate_keys_for_replicas()

        output(log_messages.GENERATED_KEYS, self._config['keys'])

    def generate_keys_for_replicas():
        for replica_id in self._config['replica_hosts'].keys():
            self.set_keys(replica_id, SigningKey.generate())

    def set_keys(id, private_key):
        self._config['keys']['private_keys'][id] = private_key
        self._config['keys']['public_keys'][id] = private_key.verify_key.encode(encoder=HexEncoder)

    def init_clients():
        for id_num in range(self._config['num_client']):
            client_id = 'c' + str(id_num)
            client_config = get_client_config(client_id)
            client = self._config['clients'][client_id]
            setup(client, args=(client_config,))
            start(client)

    def get_client_config(client_id):
        client_config = {
            'id': client_id,
            'workload': self._config['workloads'][client_id],
            'private_key': self._config['keys']['private_keys'][client_id],
            'public_keys': self._config['keys']['public_keys'],
            'client_timeout': self._config['client_timeout'] / 1000,
            'olympus': {'id': self._id, 'process_id': self._process_id},
            'replicas': self._config['replicas'],
            'head_id': self._config['head_id'],
            't': self._config['t']
        }
        return client_config

    def init_replicas():
        self._replicas = []
        prev_replica = None
        preceding_replica_ids = []
        self._config['replicas'] = {}
        self._config['replicas'] = {'r' + str(id_num): new(o_replica.Replica)
                                    for id_num in range(0, len(self._config['replica_hosts']))}
        for id_num in range(0, len(self._config['replica_hosts'])):
            replica_id = 'r' + str(id_num)
            replica = self._config['replicas'][replica_id]
            replica_config = {
                'id': replica_id,
                'clients': self._config['clients'],
                'private_key': self._config['keys']['private_keys'][replica_id],
                'public_keys': self._config['keys']['public_keys'],
                'timeout': self._config['nonhead_timeout'] / 1000,
                'prev_replica_ids': preceding_replica_ids,
                'type': 'replica',
                'current_config': self._current_config,
                'prev_replica': prev_replica,
                'checkpt_interval': self._config['checkpt_interval'],
                'replicas': self._config['replicas'],
                'olympus': {'id': self._id, 'process_id': self._process_id}
            }
            next_replica_id = 'r' + str(id_num + 1)
            replica_config['next_replica'] = self._config['replicas'][next_replica_id] \
                if next_replica_id in self._config['replicas'].keys() else None
            replica_config['failures'] = []
            if self._current_config in self._config['failures']:
                if replica_id in self._config['failures'][self._current_config]:
                    replica_config['failures'] = self._config['failures'][self._current_config][replica_id]

            if id_num == 0:
                replica_config['type'] = 'head'
                replica_config['timeout'] = self._config['head_timeout'] / 1000
                self._config['head_id'] = replica_id
            elif id_num == len(self._config['replica_hosts']) - 1:
                replica_config['type'] = 'tail'
                self._config['tail_id'] = replica_id

            prev_replica = replica
            id_num += 1
            setup(replica, args=(replica_config,))
            start(replica)
            self._replicas.append(replica_id)
            preceding_replica_ids.append(replica_id)

    def receive(msg=('reconfig_request', message, sender_id), from_=self._config['replicas'].values()):
        if not Commons.is_valid_signature(message['content'], message['signed_content'],
                                          self._config['keys']['public_keys'][sender_id]):
            output(log_messages.INVALID_SIGNATURE, sender_id, level=logging.ERROR)
            return

        output("Received reconfig request from: ", sender_id)

        if not message['content'].get('result_shuttle_timeout', False) \
                and not self._is_valid_misbehavior_proof(message['content'].get('misbehavior_proof', None), sender_id):
            output('Received invalid reconfiguration request from: ', sender_id)
            return

        output('Received valid reconfiguration request from: ', sender_id)
        for replica in self._config['replicas'].items():
            wedge_request_message = {
                'content': {
                    'requested_by_id': sender_id
                }
            }
            wedge_request_message['signed_content'] = Commons.sign(wedge_request_message['content'],
                                                                   self._config['keys']['private_keys'][self._id])

            send(('wedge', wedge_request_message), to=replica[1])
            output("Sent wedge request to: ", replica[0])

        if await(self._num_wedged_responses >= (self._config['t'] + 1)):
            pass
            # todo : handle wedged_quorum_unsatisified (timeout)

    def receive(msg=('wedged', message, replica_id), from_=self._config['replicas'].values()):
        output('Received wedged message from replica:', replica_id)
        output(self._config['keys']['public_keys'])
        output(self._config['keys']['public_keys'][replica_id])
        # if not Commons.is_valid_signature(message['content'], message['signed_content'],
        #                                   self._config['keys']['public_keys'][replica_id]):
        #     output(log_messages.INVALID_SIGNATURE, replica_id, level=logging.ERROR)
        #     return

        validation_result = True
        for order_proof in message["content"]["history"]:
            replica_ids = []
            for index in range(0, self._replicas.index(replica_id)):
                replica_ids.append(self._replicas[index])
            validation_output = Commons.is_valid_order_proof(order_proof, replica_ids,
                                                             self._config['keys']['public_keys'], self._id)
            if not validation_output[0]:
                output(validation_output[1])
                output('Received invalid order proof: ', order_proof, " from=", replica_id)
                validation_result = False
                break

        if validation_result:
            self._num_wedged_responses += 1
            output('Validated order proof successfully: ', order_proof, ' from=', replica_id)

    def initialize():
        self.parse_config()
        self.generate_keys()
        self.create_clients()
        self.init_replicas()
        self.init_clients()

    def reconfigure_cluster():
        self._terminate_replicas()
        self.generate_keys_for_replicas()
        self.init_replicas()

    def _terminate_replicas():
        for replica in self._config['replicas'].values():
            message = {
                'content': {
                    'terminate': True
                }
            }
            message['signed_content'] = Commons.sign(message['content'],
                                                     self._config['keys']['private_keys'][self._id])
            send(('abort', message), to=replica[1])
            output('Sent abort command to replica :', replica[0])

    def run():
        await(False)

    # On receipt of a config_request from a client
    def receive(msg=('config_request', message, client_id), from_=self._config['clients'].values()):
        output(log_messages.CONFIG_REQUEST_RECEIVED, client_id)
        if not Commons.is_valid_signature(message['content'], message['signed_content'],
                                          self._config['keys']['public_keys'][client_id]):
            output(log_messages.INVALID_SIGNATURE, client_id, level=logging.ERROR)
            return

        config_message = {
            'content': get_client_config(client_id)
        }
        config_message['signed_content'] = Commons.sign(config_message['content'],
                                                        self._config['keys']['private_keys'][self._id])
        send(('config', config_message), to=self._config['clients'][client_id])

        output(log_messages.CONFIG_SENT, client_id)

    def create_clients():
        for id_num in range(self._config['num_client']):
            self._config['clients']['c' + str(id_num)] = new(o_client.Client)

    def _is_valid_misbehavior_proof(misbehavior_proof, reported_by_id):
        if misbehavior_proof is None:
            return False
        if 'order_proof' in misbehavior_proof:
            replica_ids = []
            for index in range(0, self._replicas.index(reported_by_id)):
                replica_ids.append(self._replicas[index])
            return not Commons.is_valid_order_proof(misbehavior_proof['order_proof'], replica_ids,
                                                    self._config['keys']['public_keys'], self._id)[0]
        elif 'result_proof' in misbehavior_proof:
            return not Commons.is_valid_result_proof(misbehavior_proof['result_proof'], self._config['replicas'],
                                                     self._config['keys']['public_keys'], self._id)[0]

        return False


def main():
    config(channel={'reliable', 'fifo'})
    olympus = new(Olympus)
    setup(olympus, args=(olympus, sys.argv[1]))
    start(olympus)
    await(False)
