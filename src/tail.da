from commons import Commons

o_replica = import_da('replica')


# noinspection PyUnresolvedReferences
class Tail(o_replica.Replica, process):
    def setup(replica_config, object=None):
        pass # super.setup(replica_config, object)

    def receive(msg=('shuttle', shuttle, replica_id), from_=super._config['prev_replica']):
        if not Commons.is_valid_signature(shuttle['signed_content'], super._config['public_keys'][replica_id]):
            output(log_messages.INVALID_SIGNATURE, level=logging.ERROR)
            return

        slot_skipped = shuttle['content']['slot'] != super._last_signed_slot + 1
        if slot_skipped:
            output(log_messages.INVALID_SLOT, level=logging.ERROR)
            return

        valid_order_proof = Commons.is_valid_order_proof(shuttle, super._config['prev_replica_ids'],
                                                         super._config['public_keys'])
        if valid_order_proof:
            result = super._perform_operation(shuttle['content']['operation'])
            super._update_order_proof(shuttle)
            super._update_result_proof(shuttle, result)

            valid_result_proof = Commons.is_valid_result(shuttle, super._config['replicas'], super._config['public_keys'])
            if not valid_result_proof:
                super._state = ReplicaState.IMMUTABLE
                #  todo phase 3 send reconfig request
                return

            result_cache_key = (shuttle['content']['operation']['id'],
                                shuttle['content']['operation']['client_id'])
            super._result_cache[result_cache_key] = shuttle

            shuttle['signed_content'] = Commons.sign(shuttle['content'], super._config['private_key'])
            send(('result_shuttle', shuttle, super._id), to=super._config['prev_replica'])
            send_result(shuttle)

            super._last_signed_slot = shuttle['content']['slot']
        else:
            super._state = ReplicaState.IMMUTABLE

            # todo send reconfig request
