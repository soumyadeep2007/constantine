import logging

import log_messages
from commons import Commons


# noinspection PyUnresolvedReferences,PyMethodParameters
class Client(process):
    def setup(client_config):
        self._id = client_config['id']
        self._workload = client_config['workload']
        self._client_timeout = client_config['client_timeout']
        self._pending_requests = {}
        self._olympus = client_config['olympus']
        self._private_key = client_config['private_key']
        self._public_keys = client_config['public_keys']
        self._replicas = client_config['replicas']
        self._head_id = client_config['head_id']

        self._config_received = False
        self._operation_id_counter = 0
        self._valid_result_received = False

    def run():
        #  run a timer and call _request_config
        for task in self._workload:
            operation = self._create_operation(task)
            self._issue_request(operation)

        await(False)

    def _request_config():
        output(log_messages.REQUESTING_CONFIG, self)
        config_request_message = _create_config_request_message()
        self._config_received = False
        send(('config_request', config_request_message, self._id), to=self._olympus['process_id'])

        if await(self._config_received):
            pass
        elif timeout(self._client_timeout):
            output(log_messages.CONFIG_REQUEST_TIMEOUT)
            self._request_config()
            
    def _create_config_request_message():
        config_request_message = {'content': {}}
        config_request_message['content']['client_id'] = self._id
        config_request_message['signed_content'] = Commons.sign(config_request_message['content'], self._private_key)
        return config_request_message

    def _create_operation(task):
        operation = {
            'id': self._operation_id_counter,
            'client_id': self._id,
            'command_string': task
        }
        output(log_messages.OPERATION_CREATED, operation)
        self._operation_id_counter += 1
        return operation

    def _issue_request(operation):
        self._valid_result_received = False

        request_message = self._create_request(operation, is_retry=False)
        pending_requests_key = (operation['id'], self._id)
        self._pending_requests[pending_requests_key] = request_message
        send(('request', request_message, self._id), to=self._replicas[self._head_id])
        output(log_messages.REQUEST_MADE, request_message)

        if await(self._valid_result_received):
            output(log_messages.RESULT_RECEIVED, self._head_id)
        elif timeout(self._client_timeout):
            output(log_messages.REQUEST_TIMEOUT, operation)
            _handle_request_timeout(request_message)

    def _create_request(operation, is_retry):
        request_message = {
            'content': {
                'is_retry': is_retry,
                'operation': operation
            }
        }
        request_message['signed_content'] = Commons.sign(request_message['content'], self._private_key)
        return request_message

    # On receipt of a config message from Olympus
    def receive(msg=('config', message), from_=self._olympus):
        if not Commons.is_valid_signature(message['signed_content'], self._public_keys[self._olympus['id']]):
            output(log_messages.INVALID_SIGNATURE, self._olympus['id'], level=logging.ERROR)
            return

        self._config_received = True
        client_config = message['content']
        self._id = client_config['id']
        self._workload = client_config['workload']
        self._client_timeout = client_config['client_timeout']
        self._pending_requests = {}
        self._olympus = client_config['olympus']
        self._private_key = client_config['private_key']
        self._public_keys = client_config['public_keys']
        self._replicas = client_config['replicas']
        self._head_id = client_config['head_id']
        output(log_messages.CONFIG_FETCHED, message['content'])

    # On receipt of a keys message
    def receive(msg=('keys', message), from_=self._olympus):
        if not Commons.is_valid_signature(message['signed_content'], self._public_keys[self._olympus['id']]):
            output(log_messages.INVALID_SIGNATURE, self._olympus['id'], level=logging.ERROR)
            return

        self._private_key = message['private_key']
        self._public_keys = message['public_keys']

    # On receipt of a result message from a replica
    def receive(msg=('result', message, replica_id), from_=self._replicas.values()):
        if not Commons.is_valid_signature(message['signed_content'], self._public_keys[replica_id]):
            output(log_messages.INVALID_SIGNATURE, level=logging.ERROR)
            return

        pending_requests_key = (message['content']['operation']['id'], message['content']['operation']['client_id'])
        if pending_requests_key not in self._pending_requests:
            output('Not a pending request', pending_requests_key)
            return

        if Commons.is_valid_result(message, self._replicas, self._public_keys):
            self._pending_requests.pop(pending_requests_key)
            self._process_result(message['content']['operation'], message['content']['result'])
            output(log_messages.VALID_RESULT_RECEIVED, message['content']['result'])
            self._valid_result_received = True
        else:
            self._retry_request(message)

    # On receipt of an error message from a replica
    def receive(msg=('error', message, replica_id), from_=self._replicas.values()):
        if not Commons.is_valid_signature(message['signed_content'], self._public_keys[replica_id]):
            return

        self._request_config()
        self._retry_request(message)

    def _process_result(operation, result):
        output(log_messages.OPERATION_RESULT_PAIR, operation, result)

    def _retry_request(message):
        message['content']['is_retry'] = True
        message['signed_content'] = Commons.sign(message['content'], self._private_key)
        output(log_messages.RETRANSMISSION, message['content']['operation'])
        for replica in self._replicas:
            send(('request', message), to=replica)

    def _handle_request_timeout(message):
        self._retry_request(message)

    def __hash__():
        return hash((self._id))

    def __eq__(other):
        return self._id == other._id
