# noinspection PyUnresolvedReferences,PyStatementEffect
import logging
from commons import Commons
from commons import ReplicaState
import log_messages
import copy
import os
import time
import traceback


class Replica(process):
    def setup(replica_config, running_state=None, event_counts=None):
        self._terminate = False
        # ======================REPLICA SECTION===============================================
        self._id = replica_config['id']
        self._config = replica_config
        self._olympus = replica_config['olympus']
        self._state = ReplicaState.ACTIVE
        self._result_cache = {}
        self._object = running_state if running_state is not None else {}
        self._last_signed_slot = 0

        self._event_counts = {}
        self._init_event_counts(event_counts)

        self._failure_trigger = None
        self._send_error = False
        self._processed_operations = {}
        self._history = []
        self._cp_running_state_hash = None
        self._latest_cp_slot = -1
        self._latest_valid_cp = None
        self._latest_result_stmt_result_cache = {}
        self._clone_object = {}
        self._activated_failures = {failure: False for failure in ['invalid_order_sig', 'invalid_result_sig',
                                                                   'change_operation', 'change_result',
                                                                   'drop_result_stmt']}
        self._immediate_failure_triggers = []
        # =================================================================================

        # ======================HEAD SECTION===============================================
        self._current_slot = 0
        self._pending_requests = set()
        self._active_timers = set()
        # =================================================================================

        self._truncate_length = 0
        self._drop_message = False
        self._drop_checkpt_stmts = False

        output("Spawned and initialized replica: ", self._id)

    def _init_event_counts(event_counts):
        #  todo : remove unused event_counts later
        # init event counts
        self._event_counts = {event_type: -1 for event_type in ['wedge_request', 'new_configuration', 'checkpoint',
                                                                'completed_checkpoint', 'get_running_state',
                                                                'catch_up',
                                                                'client_events']}
        self._event_counts['client_events'] = {event_type: {} for event_type in
                                               ['forwarded_request', 'client_request',
                                                'shuttle', 'result_shuttle']}
        for event_type in self._event_counts['client_events']:
            for client_id in self._config['clients']:
                self._event_counts['client_events'][event_type][client_id] = -1

        self._event_counts['new_configuration'] = self._config['current_config'] - 1

        #  ========================RECEIVERS=============================================

    def receive(msg=('request', message, sender_id),
                from_=(self._config['clients'].values() + self._config['next_replica'])):  # todo: resolve
        output("Received request message (source, client_id, operation_id, self_id) ",
               sender_id, message['content']['operation']['client_id'], message['content']['operation']['id'], self._id)

        client_id = message['content']['operation']['client_id']

        trigger_type = 'forwarded_request'
        if sender_id.startswith('c'):
            trigger_type = 'client_request'

        self._update_event_counts(trigger_type, client_id)
        self._apply_failure(trigger_type, None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(message['content'], message['signed_content'],
                                          self._config['public_keys'][sender_id]):
            output(log_messages.INVALID_SIGNATURE, sender_id)
            return

        if self._state == ReplicaState.IMMUTABLE:
            if sender_id == client_id:
                output(log_messages.SENDING_ERROR_MESSAGE, client_id, self._id)
                message['signed_content'] = Commons.sign(message['content'], self._config['private_key'])
                send(('error', message, self._id), to=self._config['clients'][client_id])
            else:
                output("Discarded request from ", sender_id, " in Replica: ", self._id,
                       " as Replica is in immutable state")
            return
        if self._config['type'] != 'head':
            self._handle_request_at_replica(message, sender_id)
        else:
            self._handle_request_at_head(message, sender_id)

    # Handle shuttle
    def receive(msg=('shuttle', shuttle, replica_id), from_=self._config['replicas']['prev_replica']):
        if self._config['type'] == 'head':
            return

        output("Received shuttle (source, client_id, operation_id, self_id) ",
               replica_id, shuttle['content']['operation']['client_id'], shuttle['content']['operation']['id'],
               self._id)

        if self._state == ReplicaState.IMMUTABLE:
            output("Discarded shuttle from ", replica_id, " in Replica: ", self._id,
                   " as Replica is in immutable state")
            return

        self._update_event_counts('shuttle', shuttle['content']['operation']['client_id'])
        self._apply_failure('shuttle', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(shuttle['content'], shuttle['signed_content'],
                                          self._config['public_keys'][replica_id]):
            output(log_messages.INVALID_SIGNATURE, replica_id)
            return

        validation_output = Commons.is_valid_shuttle_header(shuttle, self._config['public_keys'],
                                                            self._config['clients'], self._id)
        if not validation_output[0]:
            output(validation_output[1])
            reason = {
                'misbehavior_proof': {
                    'invalid_client_request_shuttle': shuttle
                }
            }
            self._send_reconfig_request(reason)
            return

        slot_skipped = shuttle['content']['slot'] != self._last_signed_slot + 1
        if slot_skipped and not shuttle['content']['is_retry']:
            output(log_messages.INVALID_SLOT, level=logging.ERROR)
            return

        valid_order_proof = Commons.is_valid_order_proof(shuttle['content']['order_proof'],
                                                         self._config['prev_replica_ids'],
                                                         self._config['public_keys'], self._id)

        if not valid_order_proof[0]:
            output(valid_order_proof[1])
            self._send_error = True
            reason = {
                'misbehavior_proof': {
                    'order_proof': shuttle['content']['order_proof']
                }
            }
            self._send_reconfig_request(reason)
            return

        request_key = (shuttle['content']['operation']['id'], shuttle['content']['operation']['client_id'])
        if request_key in self._processed_operations:
            result = self._processed_operations[request_key]
        else:
            result = Commons.perform_operation(shuttle['content']['operation']['command_string'], self._object)
            self._processed_operations[request_key] = result
            if 0 == shuttle['content']['slot'] % self._config['checkpt_interval']:
                self._cp_running_state_hash = Commons.hash(sorted(self._object.items()))
                self._latest_cp_slot = shuttle['content']['slot']
                output("Set '_cp_running_state_hash' in Replica: ", self._id, " based on Running State: ",
                       self._object, " with hash: ", self._cp_running_state_hash, " for slot: ", self._latest_cp_slot)

        self._update_order_proof(shuttle)
        self._update_history(shuttle['content']['order_proof'])

        self._update_result_proof(shuttle, result)

        self._last_signed_slot = shuttle['content']['slot']

        if self._config['type'] != 'tail':
            self._handle_shuttle_at_replica(shuttle)
        else:
            self._handle_shuttle_at_tail(shuttle)

    # Handling result shuttle
    def receive(msg=('result_shuttle', shuttle, replica_id), from_=self._config['replicas']['next_replica']):
        if self._config['type'] == 'tail':
            return

        output("Received result shuttle (source, client_id, operation_id, self_id) ",
               replica_id, shuttle['content']['operation']['client_id'], shuttle['content']['operation']['id'],
               self._id)

        if self._state == ReplicaState.IMMUTABLE:
            output("Discarded result shuttle from ", replica_id, " in Replica: ", self._id,
                   " as Replica is in immutable state")
            return

        self._update_event_counts('result_shuttle', shuttle['content']['operation']['client_id'])
        self._apply_failure('result_shuttle', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(shuttle['content'], shuttle['signed_content'],
                                          self._config['public_keys'][replica_id]):
            output(log_messages.INVALID_SIGNATURE, replica_id)
            return

        valid_result_proof = Commons.is_valid_result_proof(shuttle['content']['result_proof'], self._config['replicas'],
                                                           self._config['public_keys'], self._id)

        if valid_result_proof[0]:
            result_cache_key = (shuttle['content']['operation']['id'],
                                shuttle['content']['operation']['client_id'])
            self._result_cache[result_cache_key] = shuttle
            shuttle['signed_content'] = Commons.sign(shuttle['content'], self._config['private_key'])
            if result_cache_key in self._pending_requests:
                self._pending_requests.discard(result_cache_key)
            if self._config['type'] != 'head':
                mod_shuttle = self._apply_failure('result_shuttle', shuttle, 'result_shuttle')

                send(('result_shuttle', mod_shuttle, self._id), to=self._config['prev_replica'])
        else:
            output(valid_result_proof[1])
            self._send_error = True
            self._state = ReplicaState.IMMUTABLE
            reason = {
                'misbehavior_proof': {
                    'result_proof': shuttle['content']['result_proof']
                }
            }
            output("Invalid result proof received at replica ", self._id, ". Sending reconfig request")
            self._send_reconfig_request(reason)

            return

        if self._config['type'] == 'head':
            if 0 == shuttle['content']['order_proof']['slot'] % self._config['checkpt_interval']:
                self._cp_running_state_hash = Commons.hash(sorted(self._object.items()))
                self._latest_cp_slot = shuttle['content']['order_proof']['slot']
                self._init_checkpointing()

    def receive(msg=('shared_object_request', message, client_id), from_=(self._config['clients'].values())):
        output("Received wedge request from Olympus in Replica: ", self._id)
        if not Commons.is_valid_signature(message['content'], message['signed_content'],
                                          self._config['public_keys'][client_id]):
            output(log_messages.INVALID_SIGNATURE, client_id)
            return

        output("Received shared_object_request from client=", client_id)

        shared_object_message = {
            'content': {
                'shared_object': self._object
            }
        }
        shared_object_message['signed_content'] = Commons.sign(shared_object_message['content'],
                                                               self._config['private_key'])

        send(('shared_object', shared_object_message, self._id), to=self._config['clients'][client_id])

    def receive(msg=('wedge', wedge_request_message), from_=(self._olympus['process_id'])):
        output("Received wedge request from Olympus in Replica: ", self._id)

        self._update_event_counts('wedge_request')
        self._apply_failure('wedge_request', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(wedge_request_message['content'], wedge_request_message['signed_content'],
                                          self._config['public_keys'][self._olympus['id']]):
            output(log_messages.INVALID_SIGNATURE, self._olympus['id'])
            return

        self._state = ReplicaState.IMMUTABLE
        wedged_message = {
            'content': {
                'reconfig_id': wedge_request_message['content']['reconfig_id'],
                'history': self._history,
                'checkpoint_proof': self._latest_valid_cp
            }
        }

        if self._truncate_length > 0:
            wedged_message['content']['history'] = self._history[:len(self._history) - self._truncate_length]
            output('Failure truncate_history applied for replica_id', self._id)
            self._truncate_length = 0

        wedged_message['signed_content'] = Commons.sign(wedged_message['content'], self._config['private_key'])

        self._apply_failure('wedge_request', wedged_message, 'wedged_message')

        send(('wedged', wedged_message, self._id), to=self._olympus['process_id'])
        output('Sent Wedged message to Olympus from replica: ', self._id)

    def receive(msg=('abort', abort_message), from_=(self._olympus['process_id'])):
        output("Received abort message from Olympus in replica: ", self._id)
        if not Commons.is_valid_signature(abort_message['content'], abort_message['signed_content'],
                                          self._config['public_keys'][self._olympus['id']]):
            output(log_messages.INVALID_SIGNATURE, self._olympus['id'])
            return

        aborted_message = {
            'content': {
                'event_counts': self._event_counts
            }
        }

        output('Sending aborted message to Olympus from: ', self._id)
        aborted_message['signed_content'] = Commons.sign(aborted_message['content'], self._config['private_key'])
        send(('aborted', aborted_message, self._id), to=self._olympus['process_id'])

        self._terminate = True

    def receive(msg=('checkpoint', checkpoint_shuttle, sender_id), from_=(self._config['prev_replica'])):
        if self._config['type'] == 'head':
            return

        self._update_event_counts('checkpoint')
        self._apply_failure('checkpoint', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        output('Received checkpoint shuttle from, in =', sender_id, self._id)

        if self._state == ReplicaState.IMMUTABLE:
            output("Discarded checkpoint shuttle from ", sender_id, " in Replica: ", self._id,
                   " as Replica is in immutable state")
            return

        if not Commons.is_valid_signature(checkpoint_shuttle['content'], checkpoint_shuttle['signed_content'],
                                          self._config['public_keys'][sender_id]):
            output(log_messages.INVALID_SIGNATURE, sender_id)
            return

        validation_result = Commons.is_valid_checkpoint_proof(checkpoint_shuttle['content']['checkpoint_proof'],
                                                              self._config['prev_replica_ids'],
                                                              self._config['public_keys'], self._id)
        if not validation_result[0]:
            output(validation_result[1])
            output("Send reconfiguration request because invalid checkpoint proof detected at ", self._id)
            reason = {
                'misbehavior_proof': {
                    'checkpoint_proof': checkpoint_shuttle['content']['checkpoint_proof']
                }
            }
            self._send_reconfig_request(reason)
            return

        if await(self._latest_cp_slot == checkpoint_shuttle['content']['checkpoint_proof']['slot']):
            pass
        elif timeout(self._config['timeout']):
            return

        if not self._update_checkpoint_proof(checkpoint_shuttle):
            return

        checkpoint_shuttle['signed_content'] = Commons.sign(checkpoint_shuttle['content'], self._config['private_key'])

        if self._config['type'] == 'tail':
            self._apply_checkpoint(checkpoint_shuttle['content']['checkpoint_proof'])

            self._apply_failure('completed_checkpoint', checkpoint_shuttle, 'completed_checkpoint_shuttle')

            if self._drop_checkpt_stmts:
                self._drop_checkpt_stmts = False
                for i in range(0, self._config['t'] + 1):
                    replica_id = 'r' + str(i)
                    del checkpoint_shuttle['content']['checkpoint_proof']['checkpoint_statements'][replica_id]
                output('Applied failure drop_checkpt_stmts at tail: ', self._id)

            send(('complete_checkpoint', checkpoint_shuttle, self._id), to=self._config['prev_replica'])
            output("Tail sent complete checkpoint shuttle for slot :",
                   checkpoint_shuttle['content']['checkpoint_proof']['slot'], " from: ", self._id)
            return

        self._apply_failure('checkpoint', checkpoint_shuttle, 'checkpoint_shuttle')

        send(('checkpoint', checkpoint_shuttle, self._id), to=self._config['next_replica'])
        output("Replica sent checkpoint shuttle for slot :",
               checkpoint_shuttle['content']['checkpoint_proof']['slot'], " from: ", self._id)

    def receive(msg=('complete_checkpoint', checkpoint_shuttle, sender_id), from_=(self._config['next_replica'])):
        if self._config['type'] == 'tail':
            return

        output('Received complete checkpoint shuttle from, in =', sender_id, self._id)

        if self._state == ReplicaState.IMMUTABLE:
            output("Discarded complete checkpoint shuttle from ", sender_id, " in Replica: ", self._id,
                   " as Replica is in immutable state")
            return

        self._update_event_counts('completed_checkpoint')
        self._apply_failure('completed_checkpoint', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applied failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(checkpoint_shuttle['content'], checkpoint_shuttle['signed_content'],
                                          self._config['public_keys'][sender_id]):
            output(log_messages.INVALID_SIGNATURE, sender_id)
            return

        validation_result = Commons.is_valid_checkpoint_proof(checkpoint_shuttle['content']['checkpoint_proof'],
                                                              self._config['replicas'],
                                                              self._config['public_keys'], self._id)
        if not validation_result[0]:
            output(validation_result[1])
            output("Send reconfiguration request because invalid checkpoint proof detected at ", self._id)
            reason = {
                'misbehavior_proof': {
                    'checkpoint_proof': checkpoint_shuttle['content']['checkpoint_proof']
                }
            }
            self._send_reconfig_request(reason)
            return

        self._apply_checkpoint(checkpoint_shuttle['content']['checkpoint_proof'])
        if self._config['type'] == 'head':
            output("Checkpointing process completed successfully until slot: ",
                   checkpoint_shuttle['content']['checkpoint_proof']['slot'])
            return

        if self._drop_checkpt_stmts:
            self._drop_checkpt_stmts = False
            for i in range(0, self._config['t'] + 1):
                replica_id = 'r' + str(i)
                del checkpoint_shuttle['content']['checkpoint_proof']['checkpoint_statements'][replica_id]
            output('Applied failure drop_checkpt_stmts at replica: ', self._id)

        checkpoint_shuttle['signed_content'] = Commons.sign(checkpoint_shuttle['content'], self._config['private_key'])

        self._apply_failure('completed_checkpoint', checkpoint_shuttle, 'completed_checkpoint_shuttle')

        send(('complete_checkpoint', checkpoint_shuttle, self._id), to=self._config['prev_replica'])
        output("Replica sent complete checkpoint shuttle for slot :",
               checkpoint_shuttle['content']['checkpoint_proof']['slot'], " from: ", self._id)

    def receive(msg=('catch_up', catch_up_message), from_=(self._olympus['process_id'])):
        output('Received catch up message from Olympus in =', self._id)

        self._update_event_counts('catch_up')
        self._apply_failure('catch_up', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(catch_up_message['content'], catch_up_message['signed_content'],
                                          self._config['public_keys'][self._olympus['id']]):
            output(log_messages.INVALID_SIGNATURE, 'Olympus')
            return

        self._clone_object = copy.deepcopy(self._object)
        latest_result_stmt_result_cache_clone = copy.deepcopy(self._latest_result_stmt_result_cache)
        for order_proof in catch_up_message['content']['delta_history']:
            result = Commons.perform_operation(order_proof['operation']['command_string'], self._clone_object)
            result_statement = {
                'operation': dict(order_proof['operation']),
                'result_hash': Commons.hash(result)
            }

            latest_result_stmt_result_cache_clone[order_proof['operation']['client_id']] = {
                'result_statement': result_statement,
                'result': result
            }

        running_state_hash = Commons.hash(sorted(self._clone_object.items()))
        caught_up_message = {
            'content': {
                'running_state_hash': running_state_hash,
                'latest_result_stmt_result_pairs': latest_result_stmt_result_cache_clone,
                'reconfig_id': catch_up_message['content']['reconfig_id']
            }
        }
        output('Sending caught up message to Olympus from replica: ', self._id)
        caught_up_message['signed_content'] = Commons.sign(caught_up_message['content'], self._config['private_key'])

        self._apply_failure('catch_up', caught_up_message, 'caught_up_message')

        send(('caught_up', caught_up_message, self._id), to=self._olympus['process_id'])

    def receive(msg=('get_running_state', get_running_state_message), from_=(self._olympus['process_id'])):
        output('Received get running state message from Olympus, in =', self._id)

        self._update_event_counts('get_running_state')
        self._apply_failure('get_running_state', None, None, 'pre')
        if self._drop_message:
            self._drop_message = False
            output("Applying failure 'drop' at Replica: ", self._id)
            return

        if not Commons.is_valid_signature(get_running_state_message['content'],
                                          get_running_state_message['signed_content'],
                                          self._config['public_keys'][self._olympus['id']]):
            output(log_messages.INVALID_SIGNATURE, 'Olympus')
            return

        output("Replica: ", self._id, " has clone object:", self._clone_object)
        running_state_message = {
            'content': {
                'running_state': self._clone_object
            }
        }
        running_state_message['signed_content'] = Commons.sign(running_state_message['content'],
                                                               self._config['private_key'])

        self._apply_failure('get_running_state', running_state_message, 'running_state_message')

        output('Sending running state message to Olympus from: ', self._id)
        send(('running_state', running_state_message), to=self._olympus['process_id'])

    # =================================================================================

    # ========================HANDLERS=============================================
    def _apply_checkpoint(checkpoint_proof):
        self._history = self._history[self._config['checkpt_interval']:]
        self._latest_valid_cp = checkpoint_proof
        output("Applied checkpoint until slot: ", checkpoint_proof['slot'], " in: ", self._id)

    def _update_checkpoint_proof(checkpoint_shuttle):
        if self._latest_cp_slot != -1 and self._cp_running_state_hash is not None and \
                        self._latest_cp_slot == checkpoint_shuttle['content']['checkpoint_proof']['slot']:
            checkpoint_shuttle['content']['checkpoint_proof']['checkpoint_statements'][self._id] = {
                'checkpoint_statement': {
                    'slot': self._latest_cp_slot,
                    'cp_running_state_hash': self._cp_running_state_hash
                }
            }
            self._latest_cp_slot = -1
            self._cp_running_state_hash = None
            checkpoint_statement_pair = checkpoint_shuttle['content']['checkpoint_proof']['checkpoint_statements'][self._id]
            checkpoint_statement_pair['signed_checkpoint_statement'] = \
                Commons.sign(checkpoint_statement_pair['checkpoint_statement'], self._config['private_key'])
            return True

        return False

    def _update_order_proof(shuttle):
        order_statement = {
            'slot': shuttle['content']['slot'],
            'operation': dict(shuttle['content']['operation'])
        }
        signed_order_statement = Commons.sign(order_statement, self._config['private_key'])
        shuttle['content']['order_proof']['order_statements'][self._id] = {
            'order_statement': order_statement,
            'signed_order_statement': signed_order_statement
        }

    def _update_history(order_proof):
        self._history.append(order_proof)
        output("Adding to history (slot, operation): ", order_proof['slot'], ", ", order_proof['operation'],
               " in Replica: ", self._id)

    def _update_result_proof(shuttle, result):
        shuttle['content']['result_proof']['result'] = result
        result_statement = {
            'operation': dict(shuttle['content']['operation']),
            'result_hash': Commons.hash(result)
        }
        signed_result_statement = Commons.sign(result_statement, self._config['private_key'])
        shuttle['content']['result_proof']['result_statements'][self._id] = {
            'result_statement': result_statement,
            'signed_result_statement': signed_result_statement
        }

        self._latest_result_stmt_result_cache[shuttle['content']['operation']['client_id']] = {
            'result_statement': result_statement,
            'result': result
        }

    def _send_result(shuttle, trigger_type):
        result_message = {
            'content': {
                'result_proof': shuttle['content']['result_proof'],
                'operation': shuttle['content']['operation']
            }
        }
        result_message['signed_content'] = Commons.sign(result_message['content'], self._config['private_key'])
        client_id = shuttle['content']['operation']['client_id']

        mod_result_message = self._apply_failure(trigger_type, result_message, 'result_shuttle')

        send(('result', mod_result_message, self._id), to=self._config['clients'][client_id])

    def _update_event_counts(message_type, client_id=None):
        if message_type in self._event_counts:
            self._event_counts[message_type] += 1
        elif message_type in self._event_counts['client_events']:
            client_maps = self._event_counts['client_events'][message_type]
            if client_id in client_maps:
                client_maps[client_id] += 1

    def _apply_failure(trigger_type, payload, payload_type, failure_application='post'):
        cloned_payload = dict(payload) if payload is not None else None

        if self._activated_failures['change_operation'] and payload_type == 'payload':
            cloned_payload['content']['operation']['command_string'] = "get('x')"
            output("Failure 'change_operation' applied for (operation, replica_id) ",
                   cloned_payload['content']['operation'], self._id)
            self._activated_failures['change_operation'] = False
        elif self._activated_failures['change_result'] and payload_type == 'result_shuttle':
            cloned_payload['content']['result_proof']['result_statements'][self._id]['result_statement'][
                'result_hash'] = Commons.hash('OK')
            cloned_payload['content']['result_proof']['result_statements'][self._id]['signed_result_statement'] = \
                Commons.sign(
                    cloned_payload['content']['result_proof']['result_statements'][self._id]['result_statement'],
                    self._config['private_key'])
            output("Failure 'change_result' applied for (operation, replica_id) ",
                   cloned_payload['content']['operation'], self._id)
            self._activated_failures['change_result'] = False
        elif self._activated_failures['drop_result_stmt'] and payload_type == 'result_shuttle':
            cloned_payload['content']['result_proof']['result_statements'].pop(self._id)
            output("Failure 'drop_result_stmt' applied for (operation, replica_id) ",
                   cloned_payload['content']['operation'], self._id)
            self._activated_failures['drop_result_stmt'] = False
        elif self._activated_failures['invalid_order_sig'] and payload_type == 'shuttle':
            cloned_payload['signed_content'] = self._get_invalid_signature()
            output('Failure invalid_order_sig applied at replica: ', self._id)
            self._activated_failures['invalid_order_sig'] = False
        elif self._activated_failures['invalid_result_sig'] and payload_type == 'result_shuttle' \
                    and self._config['type'] == 'tail':
            cloned_payload['content']['result_proof']['result_statements'][self._id]['signed_content'] = \
                self._get_invalid_signature()
            output('Failure invalid_result_sig applied at replica: ', self._id)
            self._activated_failures['invalid_result_sig'] = False
        elif self._activated_failures['invalid_result_sig'] and payload_type == 'shuttle':
            cloned_payload['content']['result_proof']['result_statements'][self._id]['signed_content'] = \
                self._get_invalid_signature()
            output('Failure invalid_result_sig applied at replica: ', self._id)
            self._activated_failures['invalid_result_sig'] = False

        selected_failures = self._get_failures(trigger_type, failure_application)
        if len(selected_failures) == 0:
            pass
            # output("No failure associated with trigger: ", trigger_type, " found in replica: ", self._id)
        for selected_failure in selected_failures:
            if selected_failure[0] == 'change_operation':
                self._activated_failures['change_operation'] = True
                output("Failure 'change_operation' activated for (operation, replica_id) ",
                       cloned_payload['content']['operation'], self._id)
            elif selected_failure[0] == 'change_result':
                self._activated_failures['change_result'] = True
                output("Failure 'change_result' activated for (operation, replica_id) ",
                       cloned_payload['content']['operation'], self._id)
            elif selected_failure[0] == 'drop_result_stmt':
                self._activated_failures['drop_result_stmt'] = True
                output("Failure 'drop_result_stmt' activated for (operation, replica_id) ",
                       cloned_payload['content']['operation'], self._id)
            elif selected_failure[0] == 'crash':
                output("Applying failure 'crash' to Replica: ", self._id, ". Node going down.......")
                logging.shutdown()
                os._exit(-1)
            elif selected_failure[0] == 'sleep':
                output("Apply failure 'sleep'  for replica_id) ",  self._id)
                time.sleep(int(int(selected_failure[1]) / 1000))
                output("Failure 'sleep' applied for replica_id) ",  self._id)
            elif selected_failure[0] == 'truncate_history':
                n = int(selected_failure[1])
                if len(self._history) <= n:
                    self._truncate_length = 0
                else:
                    self._truncate_length = n
                output('Failure truncate_history activated for replica_id', self._id)
            elif selected_failure[0] == 'extra_op':
                Commons.perform_operation("put('a','a')", self._object)
                output('Failure "extra_op" applied for Replica: ', self._id)
            elif selected_failure[0] == 'increment_slot':
                if self._config['type'] == 'head':
                    self._current_slot += 1
                    output('Failure "increment_slot" applied in Head: ', self._id)
            elif selected_failure[0] == 'drop_checkpt_stmts':
                self._drop_checkpt_stmts = True
                output('Failure "drop_checkpt_stmts" activated for replica id: ', self._id)
            elif selected_failure[0] == 'drop':
                self._drop_message = True
                output('Failure "drop" activated in replica id: ', self._id)
            elif selected_failure[0] == 'invalid_order_sig':
                self._activated_failures['invalid_order_sig'] = True
                output('Failure "invalid_order_sig" activated at replica: ', self._id)
            elif selected_failure[0] == 'invalid_result_sig':
                self._activated_failures['invalid_result_sig'] = True
                output('Failure "invalid_result_sig" activated at replica: ', self._id)

        if cloned_payload is not None:
            cloned_payload['signed_content'] = Commons.sign(cloned_payload['content'], self._config['private_key'])

        return cloned_payload

    def _get_invalid_signature():
        return Commons.sign("ajhsjhdbahsbsuqbkdkjbuhbajlbkkabdslbakjscbajkhbdkl", self._config['private_key'])

    def _get_failures(trigger_type, failure_application):
        # output("Checking for failure associated with trigger, application: ", (trigger_type, failure_application),
        #        " in replica: ", self._id)
        selected_failures = []
        failures = self._config.get('failures', {})
        if trigger_type not in failures:
            return selected_failures

        failures = failures.get(trigger_type, [])
        event_count = self._event_counts.get(trigger_type, -1)
        for failure in failures:
            if failure['trigger_point']['client_id'] is not None:
                client_id = failure['trigger_point']['client_id']
                event_count = self._event_counts['client_events'][trigger_type].get(client_id, -1)

            if failure['trigger_point']['application'] == failure_application and \
                            failure['trigger_point']['event_num'] == event_count:
                selected_failures.append(failure['failure'])
                failures.remove(failure)

        return selected_failures


    # =================================================================================

    # ======================REPLICA SECTION===============================================

    def _handle_request_at_replica(message, sender_id):
        if not message['content']['is_retry']:
            return
        client_id = message['content']['operation']['client_id']

        trigger_type = 'forwarded_request'
        if sender_id.startswith('c'):
            trigger_type = 'client_request'

        result_cache_key = (message['content']['operation']['id'], client_id)
        if result_cache_key in self._active_timers:
            output("Timer already started for request: ", result_cache_key, " in Replica: ", self._id, ". Discarding..")
            return

        if result_cache_key in self._result_cache:
            result_shuttle = self._result_cache[result_cache_key]
            self._send_result(result_shuttle, trigger_type)
        else:
            message['signed_content'] = Commons.sign(message['content'], self._config['private_key'])
            send(('request', message, self._id), to=self._config['prev_replica'])
            self._active_timers.add(result_cache_key)
            if await(result_cache_key in self._result_cache):
                self._active_timers.discard(result_cache_key)
            elif timeout(self._config['timeout']):
                output('Result Shuttle Timeout in Replica: ', self._id)
                self._send_reconfig_request({'timeout': True})

    def _handle_shuttle_at_replica(shuttle):
        shuttle['signed_content'] = Commons.sign(shuttle['content'], self._config['private_key'])

        mod_shuttle = self._apply_failure('shuttle', shuttle, 'shuttle')

        send(('shuttle', mod_shuttle, self._id), to=self._config['next_replica'])

    def _send_reconfig_request(reason):
        reconfig_request = {
            'content': {
                'sender_id': self._id
            }
        }
        if reason.get('timeout', False):
            reconfig_request['content']['result_shuttle_timeout'] = True
        else:
            reconfig_request['content']['result_shuttle_timeout'] = False
            reconfig_request['content']['misbehavior_proof'] = reason['misbehavior_proof']

        reconfig_request['signed_content'] = Commons.sign(reconfig_request['content'], self._config['private_key'])
        send(('reconfig_request', reconfig_request, self._id), to=self._config['olympus']['process_id'])
        output('Sent reconfiguration request to Olympus from :', self._id)

    # =================================================================================

    # ======================HEAD SECTION===============================================
    def _handle_request_at_head(message, sender_id):
        client_id = message['content']['operation']['client_id']
        request_key = (message['content']['operation']['id'], client_id)

        trigger_type = 'forwarded_request'
        if sender_id.startswith('c'):
            trigger_type = 'client_request'

        reply_cached_for_request = request_key in self._result_cache
        reply_pending_for_request = request_key in self._pending_requests
        if reply_cached_for_request:
            output(log_messages.RESULT_CACHED, client_id)
            result_shuttle = self._result_cache[request_key]
            self._send_result(result_shuttle, trigger_type)
        elif reply_pending_for_request:
            output(log_messages.RESULT_PENDING)
            self._handle_retransmission_in_head(request_key, client_id, trigger_type)
        else:
            shuttle = self._process_request(message)

            mod_shuttle = self._apply_failure(trigger_type, shuttle, 'shuttle')

            send(('shuttle', mod_shuttle, self._id), to=self._config['next_replica'])

            if message['content']['is_retry']:
                self._handle_retransmission_in_head(request_key, client_id, trigger_type)

    def _handle_retransmission_in_head(request_key, client_id, trigger_type):
        if request_key in self._active_timers:
            return

        self._active_timers.add(request_key)
        if await(request_key not in self._pending_requests):
            output(log_messages.RESULT_SENT_AFTER_WAIT, client_id)
            result_shuttle = self._result_cache[request_key]
            self._send_result(result_shuttle, trigger_type)
            self._active_timers.discard(request_key)
        elif timeout(self._config['timeout']):
            output('Result Shuttle Timeout in head: ', self._id)
            self._send_reconfig_request({'timeout': True})

    def _process_request(message):
        request_key = (message['content']['operation']['id'], message['content']['operation']['client_id'])
        output('Head is processing request (operation_id, client_id)', request_key)
        if request_key in self._processed_operations:
            processed_result = self._processed_operations[request_key]
            result = processed_result['result']
            slot = processed_result['slot']
        else:
            slot = self._get_slot()
            result = Commons.perform_operation(message['content']['operation']['command_string'], self._object)

        shuttle = self._create_shuttle(message, slot)
        self._update_order_proof(shuttle)
        self._update_history(shuttle['content']['order_proof'])

        self._update_result_proof(shuttle, result)
        shuttle['signed_content'] = Commons.sign(shuttle['content'], self._config['private_key'])
        self._processed_operations[request_key] = {'result': result, 'slot': slot}
        self._pending_requests.add(request_key)
        return shuttle

    def _create_shuttle(message, slot):
        return {
            'content': {
                'slot': slot,
                'is_retry': message['content']['is_retry'],
                'operation': message['content']['operation'],
                'order_proof': {
                    'slot': slot,
                    'operation': message['content']['operation'],
                    'order_statements': {},
                    'client_request_message': message
                },
                'result_proof': {
                    'result_statements': {}
                }
            }
        }

    def _get_slot():
        self._current_slot += 1
        return self._current_slot

    def _create_checkpoint_shuttle():
        checkpoint_shuttle = {
            'content': {
                'checkpoint_proof': {
                    'slot': self._latest_cp_slot,
                    'checkpoint_statements': {}
                }
            }
        }

        return checkpoint_shuttle

    def _init_checkpointing():
        checkpoint_shuttle = self._create_checkpoint_shuttle()
        self._update_checkpoint_proof(checkpoint_shuttle)
        checkpoint_shuttle['signed_content'] = Commons.sign(checkpoint_shuttle['content'], self._config['private_key'])
        send(('checkpoint', checkpoint_shuttle, self._id), to=self._config['next_replica'])
        output("Head initiated checkpointing and sent checkpoint shuttle for slot :",
               checkpoint_shuttle['content']['checkpoint_proof']['slot'], " from: ", self._id, " to:",
               self._config['next_replica'])

    # =================================================================================

    # ========================TAIL SECTION=============================================
    def _handle_shuttle_at_tail(shuttle):
        valid_result_proof = Commons.is_valid_result_proof(shuttle['content']['result_proof'], self._config['replicas'],
                                                           self._config['public_keys'], self._id)

        if not valid_result_proof:
            self._send_error = True
            output("Send reconfiguration request because invalid result proof detected at the tail ", self._id)
            reason = {
                'misbehavior_proof': {
                    'result_proof': shuttle['content']['result_proof']
                }
            }
            self._send_reconfig_request(reason)
            return

        result_cache_key = (shuttle['content']['operation']['id'],
                            shuttle['content']['operation']['client_id'])
        self._result_cache[result_cache_key] = shuttle

        shuttle['signed_content'] = Commons.sign(shuttle['content'], self._config['private_key'])
        mod_shuttle = self._apply_failure('shuttle', shuttle, 'result_shuttle')

        send(('result_shuttle', mod_shuttle, self._id), to=self._config['prev_replica'])
        self._send_result(shuttle, 'shuttle')

    # =================================================================================

    def run():
        if await(self._terminate):
            output("Shutting down replica: ", self._id)


def main():
    replica = new(Replica, args=({},))
    start(replica)
